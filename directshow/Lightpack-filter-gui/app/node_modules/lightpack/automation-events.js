const TimePattern = "\\b(1[0-2]|[0-9]):[0-5][0-9][ap]m";
const lightpack = require("./lightpack-api"),
    http = require('http'),
    https = require('https');

var videoStateSeekTimer = null,
    pendingAutomationEvent = null,
    pendingAutomationTimeout = null,
    lastAutomationDate = 0;

function requestEvent(name, callback) {
    let data = lightpack.getVideoEventData(name);
    console.log("Request auto event", name, data);
    if (data) {
        let event = new AutomationEvent(name, data, callback);
        if (event.canRun()) {
            if (pendingAutomationTimeout) {
                clearTimeout(pendingAutomationTimeout);

                // Do not fire last pending event but need to override it so just call the callback
                if (pendingAutomationEvent) {
                    if (pendingAutomationEvent.callback) {
                        pendingAutomationEvent.callback("cancelled");
                    }
                } else {
                    console.error("Trying to run callback of pending event but not found...");
                }
                pendingAutomationTimeout = null;
            }
            let timeDiff = Date.now() - lastAutomationDate;
            if (timeDiff < lightpack.getDelayedTimeBetweenEvents()) {
                pendingAutomationEvent = event;
                pendingAutomationTimeout = setTimeout(function() {
                    pendingAutomationTimeout = null;
                    pendingAutomationEvent.fire();
                    pendingAutomationEvent = null;
                }, lightpack.getDelayedTimeBetweenEvents() - timeDiff);
            } else {
                event.fire();
            }
        }
    } else if (callback) {
        callback(new Error("Event does not have valid data"));
    }
}

//  ============================================
//  AutomationEvent Class
//  ============================================

function AutomationEvent(name, data, callback) {
    this.name = name;
    this.callback = callback;

    this.start = data.start;
    this.end = data.end;
    this.enabled = data.enabled;
    this.url = data.url;
}

AutomationEvent.prototype.fire = function() {
    console.log("Run automated event", this.name, this.data);
    lastAutomationDate = Date.now();
    var protocol = this.url.startsWith("https") ? https : http;
    protocol.get(this.url, function(res) {
        if (res.statusCode !== 200) {
            console.log("Automation Error: Request failed with status code " + res.statusCode);
        }
        res.resume();
        if (this.callback) {
            this.callback();
        }

        // Update the last automation date to now if still waiting
        if (pendingAutomationTimeout && lightpack.getDelayedTimeBetweenEvents() > 0) {
            lastAutomationDate = Date.now();
            clearTimeout(pendingAutomationTimeout);
            pendingAutomationTimeout = setTimeout(function() {
                pendingAutomationTimeout = null;
                pendingAutomationEvent.fire();
                pendingAutomationEvent = null;
            }, lightpack.getDelayedTimeBetweenEvents());
        }
    }.bind(this)).on("error", function(e) {
        console.error("Automation Error", e);
        if (this.callback) {
            this.callback(e);
        }
    }.bind(this));
}

AutomationEvent.prototype.canRun = function() {
    if (this.enabled) {
        // Check if we can run the event now based on time
        let now = Date.now();
        if (this.start != "anytime") {
            if (!this.start.match(TimePattern)) {
                console.log("BAD: for some reason the time saved is incorrect format!");
                if (this.callback) {
                    this.callback(new Error("Time is incorrect format"));
                }
                return false;
            }
            now = Date.now();
            let startTime = this.__timeTextToTimestamp(this.start);

            // Check if are passed the current time
            if (startTime > now) {
                if (this.callback) {
                    this.callback("ignored");
                }
                return false;         // Now is before the start time, do nothing
            }

            // In case the end time is an earlier time than start, then add a day for next day
            let endTime = this.__timeTextToTimestamp(this.end);
            if (startTime > endTime) {
                endTime += 24 * 60 * 60 * 1000;     // 1 day
            }

            // Now automate if before the end time
            if (endTime < now) {
                if (callback) {
                    callback("ignored");
                }
                return false;         // Now is after the end time, do nothing
            }
        }
        return true;
    }
    return false;
}

AutomationEvent.prototype.__timeTextToTimestamp = function(text) {
    var now = new Date();
    text = text.substring(0, text.length - 2) + " " + text.substring(text.length - 2);
    return Date.parse((now.getMonth() + 1) + "-" + now.getDate() + "-" + now.getFullYear() + " " + text);
}

//  ============================================
//  Exports
//  ============================================
exports.debug = function(c) {
    console = c;
}

exports.fireEvent = function(name, callback) {
    if (videoStateSeekTimer) {
        clearTimeout(videoStateSeekTimer);
        videoStateSeekTimer = null;
    }
    if (name == "play" || name == "close") {
        requestEvent(name, callback);
    } else if (name == "pause") {
        // Never pause immediately incase of seek, wait some time before
        videoStateSeekTimer = setTimeout(function() {
            videoStateSeekTimer = null;
            requestEvent(name, callback);
        }, 700);
    } else {
        console.log("Invalid automation name", name);
        return callback(new Error("Invalid automation name=" + name));
    }
}

exports.saveVideoEventData = function(name, enabled, url, startTime, endTime) {
    lightpack.saveVideoEventData(name, enabled, url, startTime, endTime);
}

exports.saveTimeBetweenEvents = function(timeMs) {
    if (!isNaN(timeMs) && timeMs > 0 && Math.floor(timeMs) == timeMs) {
        lightpack.setDelayedTimeBetweenEvents(timeMs);
    }
}
