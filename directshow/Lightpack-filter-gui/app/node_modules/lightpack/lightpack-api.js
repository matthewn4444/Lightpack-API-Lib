// This is a common API to communicate between the filter and directly to the lightpack device
var fs = require("fs"),
    path = require("path"),
    filter = require("./lightpack-filter"),
    client = require("./prismatik-client"),
    device = require("./lightpack");

var API_KEY = "{15b3fc7b-5495-43e0-801f-93fe73742962}";
var INI_FILE = "settings.ini";
var WRITE_WAIT = 500;
var SLIDER_DEPTH_MAX = 30;

var settingsPath = path.dirname(process.execPath);
var currentObj = null;
var isConnected = false;
var server = null;
var connectionTimer = null;
var writeTimer = null;
var stateHasChanged = false;
var api = {};

// Default States, these will change based on the config file
var states = {
    numberOfLeds: 0,
    brightness: 100,
    gamma: 2.2,
    smooth: 20,
    horizontalDepth: 15,
    verticalDepth: 10,
    positions: [],
    isOn: true,
    isOnWhenClose: false,
};

var listeners = {
    connect: null,
    disconnect: null,
    play: null,
    pause: null,
    filterConnect: null,
    filterDisconnect: null,
};

var document = null;

exports.a = function(d){
    document = d;
}

function log(/*...*/) {
    if (document) {
        var div = document.createElement("div");
        var text = "[empty string]";
        if (arguments.length) {
            text = typeof(arguments[0]) == "undefined" ? "undefined" : arguments[0].toString();
            for (var i = 1; i < arguments.length; i++) {
                text += " " + (typeof(arguments[i]) == "undefined" ? "undefined" : arguments[i]);
            }
        }
        div.appendChild(document.createTextNode(text));
        var divCont = document.getElementById("output");
        divCont.appendChild(div);
        divCont.scrollTop = divCont.scrollHeight;
    }
}

var console = {
    log: log
}

//  ============================================
//  Private functions
//  ============================================
function startServer(port, host) {
    filter.startServer(function() {
        log("Runnign socket server");
    }, port, host);

    filter.on("socketconnect", function(){
        if (listeners.filterConnect) {
            listeners.filterConnect.call(exports);
        }
        filterConnected.apply(exports, arguments);
    })
    .on("socketdisconnect", function() {
        // DO NOT SET isConnected = false because this would cause a 2nd connect event
        if (listeners.filterDisconnect) {
            listeners.filterDisconnect.call(exports);
        }
        currentObj = null;
        var max_attempts = 2;
        function rConnect(i) {
            if (i < max_attempts) {
                internalConnect(function(success){
                    if (!success) {
                        setTimeout(function(){
                            rConnect(i + 1);
                        }, 300);
                    }
                }, true);
            } else {
                notifyDisconnect();
            }
        }
        rConnect(0);
    })
    .on("connect", function() {
        log("filter connected to lights");
        currentObj = filter;
        notifyConnect();
    })
    // The filter is gone, now we must reconnect either device or client
    .on("disconnect", function(){
        notifyDisconnect(function() {
            currentObj = filter;        // Set this back because we give priority to the filter
        });
    })

    // Handle when playing and not playing video
    .on("play", function(){
        if (listeners.play) {
            listeners.play.call(api);
        }
        stopConnectionPing();
    }).on("pause", function(){
        if (listeners.pause) {
            listeners.pause.call(api);
        }
    });
}

// Handle Prismatik disconnections
client.on("error", function(){
    // When disconnected we should try to reconnect to the device
    currentObj = null;
    connect();
});

function startConnectionPing() {
    stopConnectionPing();
    connectionTimer = setInterval(function(){
        if (currentObj == filter) {
            stopConnectionPing();
        } else {
            // Always reconnect and keep track of the number of leds
            internalConnect(function(yes) {
                getCountLeds();
            });
        }
    }, 1000);
}

function stopConnectionPing() {
    if (connectionTimer) {
        clearInterval(connectionTimer);
    }
    connectionTimer = null;
}

function setPort(p, callback) {
    filter.setPort(p, function(success){
        if (success) {
            setStateChanged();
            log("Changed port to", p);
        }
        if (callback) {
            callback.call(api, success);
        }
    });
}

function log10(n) {
    return Math.log(n) / Math.log(10);
}

//  ============================================
//  Settings File functions
//  ============================================
function setStateChanged() {
    if (!writeTimer) {
        writeTimer = setInterval(function() {
            if (stateHasChanged) {
                // Write file
                stateHasChanged = false;
                saveSettings();
            } else {
                clearInterval(writeTimer);
                writeTimer = 0;
            }
        }, WRITE_WAIT);
    }
    stateHasChanged = true;
}

function signifDigits(percent, digits) {
    var v = Math.pow(10, digits);
    return Math.round(percent * v) / v;
}

function stringifyPosition(posObj) {
    var rect = posObj.rect;
    return posObj.side + signifDigits(posObj.percent, 2) + ":" + signifDigits(rect.x, 2)
            + "," + signifDigits(rect.y, 2) + "," + signifDigits(rect.width, 2)
            + "," + signifDigits(rect.height, 2);
}

function saveSettings(callback) {
    callback = callback || function(){};
    // Save the file
    var data = "[General]\n" +
                "port=" + filter.getPort() + "\n" +
                "\n[State]\n" +
                "on=" + (states.isOn ? 1 : 0) + "\n" +
                "smooth=" + states.smooth + "\n" +
                "brightness="+ states.brightness + "\n" +
                "gamma=" + states.gamma + "\n" +
                "onWhenClose=" + (states.isOnWhenClose ? 1 : 0) + "\n" +
                "\n[Positions]\n" +
                "horizontalDepth=" + states.horizontalDepth + "\n" +
                "verticalDepth=" + states.verticalDepth + "\n";
    for (var i = 0; i < states.positions.length; i++) {
        var posObj = states.positions[i];
        data += "led" + (i + 1) + "=" + stringifyPosition(posObj) + "\n";
    }
    fs.writeFile(settingsPath + "/" + INI_FILE, data, function(err) {
        if (err) {
            throw err;
        }
        callback(true);
    });
}

function parseFloatDef(str, def) {
	var n = parseFloat(str, 10);
	return isNaN(n) ? def : n;
}

function readSettings(callback) {
    // Load the data into this API
    var values = {};
    var file = settingsPath + "/" + INI_FILE;
    fs.exists(file, function(exists) {
        if (exists) {
            fs.readFile(file, function(err, contents) {
                if (err) {
                    throw err;
                }
                var data = contents.toString();
                var success = true;
                var lines = data.indexOf("\r") != -1 ? data.split("\r\n") : data.split("\n");
                var ledPosArr = [];
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line == "") {
                        continue;
                    }
                    var s = line.indexOf("=");
                    if (s == -1) {
                        // Skip titles and comments
                        if (line.charAt(0) == '[' || line.charAt(0) == ';') {
                            continue;
                        }
                        throw new Error("INI file is not formatted correctly.");
                    }
                    var command = line.substring(0, s).trim();
                    var value = line.substring(s + 1).trim();
                    if (command == "port") {
                        values.port = parseInt(value, 10);
                    } else if (command == "smooth") {
                        values.smooth = parseInt(value, 10);
                    } else if (command == "on") {
                        values.isOn = parseInt(value, 10) === 1;
                    } else if (command == "onWhenClose") {
                        values.onWhenClose = parseInt(value, 10) === 1;
                    } else if (command == "brightness") {
                        values.brightness = parseInt(value, 10);
                    } else if (command == "gamma") {
                        values.gamma = parseFloat(value, 10);
                    } else if (command == "horizontalDepth") {
                        values.horizontalDepth = parseFloat(value, 10);
                    } else if (command == "verticalDepth") {
                        values.verticalDepth = parseFloat(value, 10);
                    } else if (command.indexOf("led") == 0) {
                        if (value.length) {
                            try {
                                var n = parseInt(command.substring(3), 10) - 1;
                                if (!ledPosArr[n]) {
                                    var parts = value.split(":"),
                                        rectValues = parts[1].split(",");
                                    ledPosArr[n] = {
                                        side: parts[0].charAt(0),
                                        percent: parseFloat(parts[0].substring(1), 10),
                                        rect: {
                                            x: parseFloatDef(rectValues[0], 0),
                                            y: parseFloatDef(rectValues[1], 0),
                                            width: parseFloatDef(rectValues[2], 16),
                                            height: parseFloatDef(rectValues[3], 16)
                                        }
                                    };
                                }
                            } catch(e) {
                                throw new Error("Failed to parse positions.");
                            }
                        }
                    } else {
                        log("Error: INI file has unknown command", command);
                    }
                }
                // Check if the positions are correct then set it
                for (var i = 0; i < ledPosArr.length; i++) {
                    if (!ledPosArr[i]) {
                        // Failed to get all the positions
                        success = false;
                        break;
                    }
                }
                if (success) {
                    values.positions = ledPosArr;
                }
                if (callback) {
                    callback(success ? values : null);
                }
            });
        } else if (callback) {
            callback();
        }
    });
}

//  ============================================
//  Connection functions
//  ============================================
function connectDevice() {
    if (device.tryToReopenDevice()) {
        console.log("connected to device");
        currentObj = device;
        notifyConnect();
        return true;
    }
    return false;
}

function connectToPrismatik(opts, callback) {
    if (!opts) {
        opts = { apikey: API_KEY }
    } else if (!opts.apikey) {
        opts.apikey = API_KEY;
    }
    client.connect(function(isConnected){
        if (isConnected) {
            // Now make sure we can lock the lightpack
            client.lock(function(gotLocked){
                if (!gotLocked) {
                    // Since we could not lock, that means we will need to disconnect
                    client.disconnect(callback);
                } else {
                    console.log("connected to prismatik");
                    currentObj = client;
                    callback(true);
                    notifyConnect();
                }
            });
        } else {
            callback(false);
        }
    }, opts);
}

function filterConnected() {
    // Since filter is now connected, this has higher priority and disconnect
    // device and Prismatik client
    internalDisconnect(function(){
        currentObj = filter;
        console.log("connected to filter");
        notifyConnect();
    });
}

function internalConnect(callback, tryPrismatik, opts) {
    callback = callback || function(){};

    if (currentObj == filter) {
        filter.signalReconnect(function(success){
            log("signalReconnect", success);
            if (success) {
                notifyConnect();
            }
            callback.call(api, success);
        });
    } else {
        log("try to connect to device")
        if (!connectDevice()) {
            if (tryPrismatik) {
                log("try to connect to prismatik")
                connectToPrismatik(opts, function(success) {
                    callback(success || currentObj);
                });
            } else {
                // Failed to connect
                if (isConnected) {
                    notifyDisconnect(function() {
                        callback(false);
                    });
                } else {
                    callback(false);
                }
            }
        } else {
            callback(true);
        }
    }
    return api;
}

function internalDisconnect(callback) {
    if (currentObj == device) {
        log("Disconnected from device");
        device.closeDevices();
    } else if (currentObj == client) {
        log("Disconnected from Prismatik");
        return client.disconnect(callback);
    }
    currentObj = null;
    callback();
}

//  ============================================
//  Notify events
//  ============================================
function notifyConnect() {
    var beforeCountLed = states.numberOfLeds;
    function runConnected() {
        if (currentObj == device) {
            startConnectionPing();
        }
        if (listeners.connect && beforeCountLed != states.numberOfLeds) {
            listeners.connect.call(api, states.numberOfLeds);
        }
    }
    isConnected = true;
    if (currentObj != device) {
        stopConnectionPing();
    }

    // Since connected to new device, we should apply the current states
    getCountLeds(function(n) {
        if (n > 0) {
            if (beforeCountLed != states.numberOfLeds) {
                setSmooth(states.smooth, function(success) {
                    if (success) {
                        setGamma(states.gamma, function(success) {
                            if (success) {
                                setBrightness(states.brightness, function(success) {
                                    if (success) {
                                        if (states.isOn) {
                                            turnOn(runConnected);
                                        } else {
                                            turnOff(runConnected);
                                        }
                                        runConnected();
                                    }
                                });
                            }
                        });
                    }
                });
            } else {
                runConnected();
            }
        }
    });
}

function notifyDisconnect(callback) {
    log("notifyDisconnect")
    var beforeCountLed = states.numberOfLeds;
    getCountLeds(function(n) {
        if (beforeCountLed != n) {
            if (listeners.disconnect) {
                listeners.disconnect.call(api, n);
            }
            if (n == 0) {
                startConnectionPing();
            }
        }
        if (n == 0) {
            isConnected = false;
            currentObj = null;
        }
        if (callback) callback();
    });
}

//  ============================================
//  Functions
//  ============================================
function proxyFunc(callback, args) {
    function handleReturnValue(success) {
        if (success === false && currentObj) {
            // For device: once disconnected, we should try to reconnect or fail
            disconnect(callback);
        }
        if (callback) {
            callback.apply(api, arguments);
        }
    }

    if (arguments.callee.caller && arguments.callee.caller.name) {
        var fnName = arguments.callee.caller.name;
        args = args || [];

        function runProxy() {
            if (currentObj == device) {
                // If crash next line, you did not make the function same name to call this
                var ret = device[fnName].apply(api, args);
                handleReturnValue(ret);
            } else if (currentObj) {
                args.push(handleReturnValue);
                // If crash next line, you did not make the function same name to call this
                currentObj[fnName].apply(api, args);
            } else if (callback) {
                callback.call(api, false);
            }
        }

        // If not connected yet try to connect
        if (!isConnected) {
            internalConnect(function(success){
                if (success) {
                    runProxy();
                } else if (callback) {
                    callback.call(api, false);
                }
            });
        } else {
            runProxy();
        }
    } else {
        throw new Error("proxyFunc was called incorrectly!");
    }
    return api;
}

function getCountLeds(callback) {
    return proxyFunc(function(r) {
        states.numberOfLeds = !!r ? r : 0;
        if (callback) callback.call(api, states.numberOfLeds);
    });
}

function setColor(n, r, g, b, callback) {
    if (isNaN(n) || isNaN(r) || isNaN(g) || isNaN(b)) {
        throw new Error("API: setColor has invalid arguments");
    }
    return proxyFunc(callback, [n, r, g, b]);
}

function setColors(colorArr, callback) {
    if (!Array.isArray(colorArr)) {
        throw new Error("API: setColors has invalid arguments");
    }
    return proxyFunc(callback, [colorArr]);
}

function setColorToAll(r, g, b, callback) {
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
        throw new Error("API: setColorToAll has invalid arguments");
    }
    return proxyFunc(callback, [r, g, b]);
}

function setGamma(value, callback) {
    value = Math.round(value * 100) / 100;
    if (value != states.gamma) {
        states.gamma = value;
        setStateChanged();
    }
    return proxyFunc(callback, [value]);
}

function setSmooth(value, callback) {
    if (states.smooth != value) {
        states.smooth = value;
        setStateChanged();
    }
    return proxyFunc(callback, [Math.floor(value)]);
}

function setExportedGamma(value, callback) {
    if (isNaN(value)) {
        throw new Error("API: setGamma has an invalid argument");
    }
    var exponent = (value / 100.0) * 2.0 - 1;
    log("Gamma", Math.pow(10, exponent));
    return setGamma(Math.pow(10, exponent), callback);
}

function setExportedSmooth(value, callback) {
    if (isNaN(value)) {
        throw new Error("API: setSmooth has an invalid argument");
    }
    return setSmooth(Math.round(255 * value / 100.0), callback);
}

function setBrightness(value, callback) {
    if (isNaN(value)) {
        throw new Error("API: setBrightness has an invalid argument");
    }
    if (states.brightness != value) {
        states.brightness = value;
        setStateChanged();
    }
    return proxyFunc(callback, [value]);
}

function setHorizontalDepth(percent) {
    // Percent is within 0 - 50
    if (percent < 0 || percent > 50) {
        throw new Error("Horizontal depth is not between 0 to 50%");
    }
    if (percent != states.horizontalDepth) {
        states.horizontalDepth = percent;
        setStateChanged();
    }
}

function setVerticalDepth(percent) {
    // Percent is within 0 - 50
    if (percent < 0 || percent > 50) {
        throw new Error("Vertical depth is not between 0 to 50%");
    }
    if (percent != states.verticalDepth) {
        states.verticalDepth = percent;
        setStateChanged();
    }
}

function sendPositionsToFilter(positionsArr, callback) {
    if (!Array.isArray(positionsArr)) {
        throw new Error("Cannot send positions because it is not an array!");
    }
    states.positions = positionsArr;
    setStateChanged();
    if (currentObj == filter) {
        filter.sendPositions(positionsArr, callback);
    } else if (callback) {
        callback.call(exports, false);
    }
}

function turnOn(callback) {
    if (!states.isOn) {
        states.isOn = true;
        setStateChanged();
    }
    return proxyFunc(callback);
}

function turnOff(callback) {
    if (states.isOn) {
        states.isOn = false;
        setStateChanged();
    }
    return proxyFunc(callback);
}

function setCloseState(isOn, callback) {
    if (states.isOnWhenClose != isOn) {
        states.isOnWhenClose = isOn;
        setStateChanged();
    }
    if (currentObj == filter) {
        filter.setCloseState(isOn, callback);
    } else if (callback) {
        callback.call(exports, true);
    }
}

function connect(opts) {
    return internalConnect(null, true, opts);
}

function disconnect() {
    internalDisconnect(notifyDisconnect);
    return api;
}

function on(eventName, fn) {
    if (fn == null || typeof(fn) == "function") {
        if (listeners.hasOwnProperty(eventName)) {
            listeners[eventName] = fn;
        }
    }
    return api;
}

// By default, try to detect when lightpack is connected to device
startConnectionPing();

// API requires connection
api.connect = connect;
api.disconnect = disconnect;
api.getCountLeds = function(){ return states.numberOfLeds; };
api.setColor = setColor;
api.setColors = setColors;
api.setColorToAll = setColorToAll;
api.turnOn = turnOn;
api.turnOff = turnOff;
api.on = on;

// API doesn't require connection
exports.setGamma = setExportedGamma;
exports.setSmooth = setExportedSmooth;
exports.setPort = setPort;
exports.setHorizontalDepth = setHorizontalDepth;
exports.setVerticalDepth = setVerticalDepth;
exports.getHorizontalDepth = function() { return states.horizontalDepth; };
exports.getVerticalDepth = function() { return states.verticalDepth; };
exports.closeFilterWindow = filter.closeWindow;
exports.sendPositions = sendPositionsToFilter;
exports.getSavedPositions = function(){ return states.positions; };
exports.isOn = function(){ return states.isOn; };
exports.isOnWhenClose = function(){ return states.isOnWhenClose; };
exports.setBrightness = setBrightness;
exports.getPort = function(){ return filter.getPort(); };
exports.getSmooth = function(){ return Math.round((states.smooth / 255.0) * 100); };
exports.getGamma = function(){ return Math.round(((log10(states.gamma) + 1) / 2.0) * 100); };
exports.getBrightness = function(){ return states.brightness; };
exports.setCloseState = setCloseState;
exports.getSettingsFolder = function() { return settingsPath; }
exports.setSettingsFolder = function(folderPath) {
    settingsPath = folderPath;

    // Check if folder path exists, if not then create it
    if (!fs.existsSync(folderPath)) {
        fs.mkdirSync(folderPath);
    }
}

exports.init = function(callback){
    // Start by loading the file and then start the server
    readSettings(function(data){
        if (data) {
            // Update values from the settings file
            if (data.hasOwnProperty("isOn")) {
                states.isOn = data.isOn;
            }
            if (data.hasOwnProperty("onWhenClose")) {
                states.isOnWhenClose = data.onWhenClose;
            }
            if (data.smooth) {
                states.smooth = data.smooth;
            }
            if (data.brightness) {
                states.brightness = data.brightness;
            }
            if (data.gamma) {
                states.gamma = data.gamma;
            }
            if (data.positions) {
                states.positions = data.positions;
            }
            if (data.horizontalDepth != null && typeof(data.horizontalDepth) !== "undefined") {
                states.horizontalDepth = Math.min(data.horizontalDepth, SLIDER_DEPTH_MAX);
            }
            if (data.verticalDepth != null && typeof(data.verticalDepth) !== "undefined") {
                states.verticalDepth = Math.min(data.verticalDepth, SLIDER_DEPTH_MAX);
            }
            filter.setPort(data.port, function(){
                startServer(data.port);
                if (callback) {
                    callback(api);
                }
            });
        } else {
            saveSettings(function() {
                startServer();     // null port uses default
                if (callback) {
                    callback(api);
                }
            });
        }
    });
}

exports.close = function(callback) {
    if (currentObj && !states.isOnWhenClose) {
        currentObj.setSmooth(50);
        currentObj.setBrightness(0);
    }
    internalDisconnect(function(){
        filter.close(callback);
    });
}
